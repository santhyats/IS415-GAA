---
title: "Prototyping Modules for Shiny App for the Geospatial Analytics Project"
author: "Santhya Selvan"
date: "23 October 2024"
date-modified: "last-modified"
execute: 
  eval: true
  echo: true
  freeze: true
---

## 10.0 Overview

.....

## 10.1 Getting Started

#### 10.1.1 Loading in the packages

For this exercise, I will be needing a variety of packages, namely:

**sf**: Used in spatial data wrangling

**tidyverse**: Used in data wrangling for non-spatial data

**tmap**: For functions relating to mapping point patterns

**sfdep:** Functions that support Exploratory Data Analysis and is compatible with the sf and tidyverse packages

**corrplot:** package to help plot correlation matrices.

**cluster, NbClust**: packges that will be helpful for our hierarchical clustering needs.

**ggpubr, GGally:** packages extended on/ based on **ggplot2**. They provide functions for plots.

```{r}
pacman::p_load(spdep, tmap, sf, ClustGeo, ggpubr, cluster, factoextra, NbClust, heatmaply, corrplot, psych, tidyverse, GGally)
```

Loading in the aspatial and spatial data

```{r}

crime_district <- read_csv("data/aspatial/crime_district.csv")
population_district <- read_csv("data/aspatial/population_district.csv")
msia_adm2_sf <- st_read(dsn = 'data/geosp', layer = 'mys_admbnda_adm2_unhcr_20210211')
```

formatting the crime data to only include the state names and their respective districts. Also filter out the rows where the data is aggregated across the crime types, as well as across the districts. since population data is from 2016-2022, we will also remove the 2023 data rows.

```{r}
crime_district <- crime_district %>% 
    filter(state != "Malaysia") %>% 
    filter(category == "assault") %>% 
    filter(district != "All") %>% 
    filter(type != "all")
```

formatting the population data table to be simpler

```{r}

library(dplyr)
library(lubridate)

# population_state_filtered <- 
pop_data <- population_district %>%
    filter(!year(ymd(date)) == 2024) %>% 
    filter(sex == 'both' | sex == 'overall' ) %>% 
    filter(age == 'overall') %>% 
    filter(ethnicity == 'overall') %>% 
    select(-c(4:6))
```

formatting the district boundary sf by dropping unnecessary columns

```{r}
adm2_sf <- msia_adm2_sf %>% select(-c(3:5, 8,9,11,12))
```

```{r}
tm_shape(adm2_sf) + tm_polygons()
```

```{r}
unique(pop_data$district)

```

```{r}


unique(adm2_sf$ADM2_EN)

```

```{r}
unique(crime_district$district)

```

```{r}
crime_district$district <- tolower(trimws(crime_district$district))
adm2_sf$ADM2_EN <- tolower(trimws(adm2_sf$ADM2_EN))
pop_data$district <- tolower(trimws(pop_data$district))

```

```{r}
library(stringr)
crime_johor<- crime_district %>%
  filter(str_detect(district,"johor bahru")) %>%
  mutate(district = 'johor bahru') %>%
  group_by(state, district,type, date) %>%
  summarise(crimes = sum(crimes))

crime_klang<- crime_district %>%
  filter(str_detect(district,"klang")) %>%
  mutate(district = 'klang') %>%
  group_by(state, district,type, date) %>%
  summarise(crimes = sum(crimes))


other_rows <- crime_district %>% 
  filter(!str_detect(district, "johor bahru"))

crime_district <- bind_rows(crime_johor, crime_klang, other_rows) %>% 
  select(-c(6)) %>% 
  mutate(category = 'assault') 
```

```{r}
crime_district<- crime_district%>% 
  mutate(district = ifelse(district == "cameron highland", "cameron highlands", district)) %>% 
  mutate(district = ifelse(district == "kuala lipis", "lipis", district)) %>% 
  mutate(district = ifelse(district == "kota kinabatangan", "kinabatangan", district)) %>% 
  mutate(district = ifelse(district == "seberang perai tengah", "s.p. tengah", district)) %>% 
  mutate(district = ifelse(district == "seberang perai utara", "s.p. utara", district)) %>% 
  mutate(district = ifelse(district == "seberang perai selatan", "s.p.selatan", district)) %>% 
  mutate(district = ifelse(district == "petaling jaya", "petaling", district)) %>% 
   mutate(district = ifelse(district == "matu daro", "matu", district))
  

pop_data <- pop_data %>% 
  mutate(district = ifelse(district == "kulai", "kulaijaya", district)) %>% 
  mutate(district = ifelse(district == "sp tengah", "s.p. tengah", district)) %>% 
  mutate(district = ifelse(district == "sp utara", "s.p. utara", district)) %>% 
  mutate(district = ifelse(district == "sp selatan", "s.p.selatan", district)) %>%
  mutate(district = ifelse(state == "w.p. labuan", "sabah", state))
   
  
```

```{r}
new_sf_2<- left_join(pop_data, crime_district, by= "district")
new_sf_2_na<- new_sf_2[rowSums(is.na(new_sf_2)) > 0,]
```

```{r}


drop_list_pop <- new_sf_2_na$district
pop_data <- pop_data %>%
  filter(!(district %in% drop_list_pop))
  
```

```{r}
adm_crime <- left_join(adm2_sf, crime_district, by= c("ADM2_EN" = "district"))
na_3 <- adm_crime[rowSums(is.na(adm_crime)) > 0,]
drop_list <- na_3$ADM2_EN
adm2_sf <- adm2_sf %>% 
  filter(!(ADM2_EN %in% drop_list))
```

```{r}
adm_crime <- left_join(adm2_sf, crime_district, by= c("ADM2_EN" = "district"))
na_3 <- adm_crime[rowSums(is.na(adm_crime)) > 0,]
```

```{r}
drop_list_pop <- new_sf_2_na$district
pop_data <- pop_data %>%
  filter(!(district %in% drop_list_pop))
  
```

```{r}

  
rate_crime_district <- crime_district %>% 
    left_join(pop_data, by = c("district", "state", "date")) %>% 
    mutate(crime_rate = (crimes / population) * 1000)

# assigning Penisular , East region
rate_crime_district <- rate_crime_district %>% 
    mutate(region = case_when(
        state %in% c("Sabah", "Sarawak") ~ "East",
        TRUE ~ "Peninsular"
  ))
```

```{r}
write_rds(pop_data, "data/rds/pop_data.rds")
write_rds(crime_district, "data/rds/crime_district.rds")
write_rds(adm2_sf, "data/rds/adm2_sf.rds")
write_rds(rate_crime_district, "data/rds/rate_crime_district.rds")
```

```{r}
pop_data<- read_rds("data/rds/pop_data.rds")
crime_district <- read_rds("data/rds/crime_district.rds")
adm2_sf <- read_rds("data/rds/adm2_sf.rds")
rate_crime_district<-("data/rds/rate_crime_district.rds")


```

-   if we doing hierarchical clusterin then we shouldnt be dividing by crime type

-   if we splitting by districts, then we would need to repeat all three clustering methods for both east and west.

-   
