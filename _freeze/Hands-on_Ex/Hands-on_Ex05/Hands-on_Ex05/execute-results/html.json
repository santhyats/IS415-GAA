{
  "hash": "9a797ddc7b6792a68ad180c939ced67d",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"5 Spatial Weights and Application\"\nauthor: \"Santhya Selvan\"\ndate: \"September 13, 2024\"\ndate-modified: \"last-modified\"\nexecute: \n  eval: true\n  echo: true\n  freeze: true\n---\n\n\n## 5.1 Overview\n\nIn this exercise, I will be computing spatial weights using R. The main learning points are:\n\n-   To perform relational joints using appropriate join function of the **dplyr** package\n\n-   Using the appropriate functions of the **spdep** package to:\n\n    -   compute spatial weights\n\n    -   calculate spatially lagged variables\n\nI will install the needed packages into our R environment first.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(sf, tidyverse, spdep, tmap, knitr)\n```\n:::\n\n\n## 5.2 Importing and Preparing Data\n\nIn this exercise, I will be using the following datasets:\n\n-   Hunan county boundary layer. This is a geospatial data set in ESRI shapefile format.\n\n-   Hunan_2012.csv: This csv file contains selected Hunan’s local development indicators in 2012.\n\n#### 5.2.1 Importing the shapefile \n\n*st_read()* of the **sf** package is used to import the shapefile into R. We will save it to a variable `hunan`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan <- st_read(dsn=\"data/geospatial\",\n                 layer=\"Hunan\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `Hunan' from data source \n  `C:\\santhyats\\IS415-GAA\\Hands-on_Ex\\Hands-on_Ex05\\data\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 88 features and 7 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 108.7831 ymin: 24.6342 xmax: 114.2544 ymax: 30.12812\nGeodetic CRS:  WGS 84\n```\n\n\n:::\n:::\n\n\n#### 5.2.2 Importing the CSV \n\nI will import the csv file using the *read_csv()* function of the **readr** package and save it to a variable named `hunan2012.`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan2012 <- read_csv(\"data/aspatial/Hunan_2012.csv\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 88 Columns: 29\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr  (2): County, City\ndbl (27): avg_wage, deposite, FAI, Gov_Rev, Gov_Exp, GDP, GDPPC, GIO, Loan, ...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n:::\n\n\n#### 5.2.3 Performing relational join\n\nThe code chunk below will be used to update the attribute table of *hunan*’s SpatialPolygonsDataFrame with the attribute fields of *hunan2012* dataframe. This is performed by using *left_join()* of **dplyr** package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan <- left_join(hunan, hunan2012) %>% \n  select(1:4, 7, 15)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nJoining with `by = join_by(County)`\n```\n\n\n:::\n:::\n\n\n## 5.3 Visualising Regional Development Indicator \n\nNow, I am going to prepare a basemap and a choropleth map showing the distribution of GDPPC 2012 by using *qtm()* of **tmap** package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbasemap <- tm_shape(hunan) +\n  tm_polygons() +\n  tm_text(\"NAME_3\", size=0.5)\n\ngdppc <- qtm(hunan, \"GDPPC\")\ntmap_arrange(basemap, gdppc, asp=1, ncol=2)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex05_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\n## 5.4 Computing Contiguity Spatial Weights\n\n## 5.5 Computing Distance-based Neighbours\n\n## 5.6 Computing weights based on IDW\n\n## 5.7 Row-standardised Weights Matrix\n\n## 5.8 Applications of Spatial Weights Matrix\n\n## \n",
    "supporting": [
      "Hands-on_Ex05_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}