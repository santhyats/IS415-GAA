{
  "hash": "a79335263da8137037fb833f31031f71",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"8 Geographical Segmentation with Spatially Constrained Clustering Techniques - Using the SKATER Approach\"\nauthor: \"Santhya Selvan\"\ndate: \"October 18, 2024\"\ndate-modified: \"last-modified\"\nexecute: \n  eval: true\n  echo: true\n  freeze: true\n---\n\n\n\n## 8.0 Overview\n\nIn this hands-on exercise, I will be exploring another method to form spatially constrained clusters that we performed in the last hands-on exercise.\n\nIt will be the SKATER approach. SKATER stands for 'Spatial K'luster Analysis by Tree Edge Removal'. This method allows us ti group spatial units based on both the similarity of a specific attribute and their spatial contiguity as well.\n\nIn order to do this, we will be using the *skater()* function of the **spdep** package.\n\n#### 8.0.1 Getting Started\n\nWe will be using the same datasets as we did in the last Handds-On Exercise. To recall,region of interest will be Shan State in Myanmar, and we aim to split this region into homogeneous segments on the basis of different means of Communication Technology: Radio, Television, Land Line Phone, Mobile Phone, Computer and Internet at home.\n\n#### 8.0.2 The data\n\nThe two datasets used are:\n\n-   Myanmar Township Boundary Data (i.e. *myanmar_township_boundaries*) : This is a GIS data in ESRI shapefile format. It consists of township boundary information of Myanmar. The spatial data are captured in polygon features.\n\n-   *Shan-ICT.csv*: This is an extract of [**The 2014 Myanmar Population and Housing Census Myanmar**](https://myanmar.unfpa.org/en/publications/2014-population-and-housing-census-myanmar-data-sheet) at the township level.\n\n#### 8.0.3 Installing packages\n\nFirstly, we will install the necessary packages needed for this exercise. The R packages needed for this exercise are as follows:\n\n-   Spatial data handling\n\n    -   **sf**, **rgdal** and **spdep**\n\n-   Attribute data handling\n\n    -   **tidyverse**, especially **readr**, **ggplot2** and **dplyr**\n\n-   Choropleth mapping\n\n    -   **tmap**\n\n-   Multivariate data visualisation and analysis\n\n    -   **coorplot**, **ggpubr**, and **heatmaply**\n\n-   Cluster analysis\n\n    -   **cluster**\n\n    -   **ClustGeo**\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(sf, rgdal, spdep, tidyverse, tmap, corrplot, ggpubr, heatmaply, cluster, ClustGeo, GGally)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: package 'rgdal' is not available for this version of R\n\nA version of this package for your version of R might be available elsewhere,\nsee the ideas at\nhttps://cran.r-project.org/doc/manuals/r-patched/R-admin.html#Installing-packages\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: unable to access index for repository http://www.stats.ox.ac.uk/pub/RWin/bin/windows/contrib/4.4:\n  cannot open URL 'http://www.stats.ox.ac.uk/pub/RWin/bin/windows/contrib/4.4/PACKAGES'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: 'BiocManager' not available.  Could not check Bioconductor.\n\nPlease use `install.packages('BiocManager')` and then retry.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in p_install(package, character.only = TRUE, ...):\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in library(package, lib.loc = lib.loc, character.only = TRUE,\nlogical.return = TRUE, : there is no package called 'rgdal'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in pacman::p_load(sf, rgdal, spdep, tidyverse, tmap, corrplot, ggpubr, : Failed to install/load:\nrgdal\n```\n\n\n:::\n:::\n\n\n\n#### 8.0.4 Data Import \n\nI will now import the geospatial and aspatial datasets into the R environment.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshan_sf <- st_read(dsn = \"data/geospatial\",\n                   layer = \"myanmar_township_boundaries\") %>% \n  filter(ST %in% c(\"Shan (East)\", \"Shan (North)\", \"Shan (South)\")) %>%\n  select(c(2:7))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `myanmar_township_boundaries' from data source \n  `C:\\santhyats\\IS415-GAA\\Hands-on_Ex\\Hands-on_Ex08\\data\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 330 features and 14 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 92.17275 ymin: 9.671252 xmax: 101.1699 ymax: 28.54554\nGeodetic CRS:  WGS 84\n```\n\n\n:::\n\n```{.r .cell-code}\nict <- read_csv (\"data/aspatial/Shan-ICT.csv\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 55 Columns: 11\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (4): District Pcode, District Name, Township Pcode, Township Name\ndbl (7): Total households, Radio, Television, Land line phone, Mobile phone,...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n:::\n\n\n\n## 8.1 SKATER Approach\n\n#### 8.1.1 Computing the Neighbours List\n\nFirst, we will convert the `shan_sf` into a sp object as functions of **spdep** only support sp objects. We will use the *as_Spatial()* function of the **sf** package to achieve this.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshan_sp <- as_Spatial(shan_sf)\n```\n:::\n\n\n\nNext, we will use *poly2nb()* of the **spdep** package to compute the neighbours list for the sp object.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshan.nb <- poly2nb(shan_sp)\n```\n:::\n\n\n\nNow that we have the boundaries of Shan state and the neighbours, we can compute the centroids for the neighbours to be used in our analysis.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncoords <- st_coordinates(\n  st_centroid(st_geometry(shan_sf)))\n\nplot(st_geometry(shan_sf), \n     border=grey(.5))\nplot(shan.nb,\n     coords, \n     col=\"purple\", \n     add=TRUE)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex08_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\n\n####  \n\n#### 8.1.2 Computing Minimum Spanning Tree\n\n##### 8.1.2.1 Calculating Edge Costs \n\nThe nbcosts() function of the spdep package will be used to compute the costs of the edges. It is the distance between the nodes.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlcosts <- nbcosts(shan.nb, ict)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in dist(rbind(data[id, , drop = FALSE], data[id.neigh, , drop =\nFALSE]), : NAs introduced by coercion\nWarning in dist(rbind(data[id, , drop = FALSE], data[id.neigh, , drop =\nFALSE]), : NAs introduced by coercion\nWarning in dist(rbind(data[id, , drop = FALSE], data[id.neigh, , drop =\nFALSE]), : NAs introduced by coercion\nWarning in dist(rbind(data[id, , drop = FALSE], data[id.neigh, , drop =\nFALSE]), : NAs introduced by coercion\nWarning in dist(rbind(data[id, , drop = FALSE], data[id.neigh, , drop =\nFALSE]), : NAs introduced by coercion\nWarning in dist(rbind(data[id, , drop = FALSE], data[id.neigh, , drop =\nFALSE]), : NAs introduced by coercion\nWarning in dist(rbind(data[id, , drop = FALSE], data[id.neigh, , drop =\nFALSE]), : NAs introduced by coercion\nWarning in dist(rbind(data[id, , drop = FALSE], data[id.neigh, , drop =\nFALSE]), : NAs introduced by coercion\nWarning in dist(rbind(data[id, , drop = FALSE], data[id.neigh, , drop =\nFALSE]), : NAs introduced by coercion\nWarning in dist(rbind(data[id, , drop = FALSE], data[id.neigh, , drop =\nFALSE]), : NAs introduced by coercion\nWarning in dist(rbind(data[id, , drop = FALSE], data[id.neigh, , drop =\nFALSE]), : NAs introduced by coercion\nWarning in dist(rbind(data[id, , drop = FALSE], data[id.neigh, , drop =\nFALSE]), : NAs introduced by coercion\nWarning in dist(rbind(data[id, , drop = FALSE], data[id.neigh, , drop =\nFALSE]), : NAs introduced by coercion\nWarning in dist(rbind(data[id, , drop = FALSE], data[id.neigh, , drop =\nFALSE]), : NAs introduced by coercion\nWarning in dist(rbind(data[id, , drop = FALSE], data[id.neigh, , drop =\nFALSE]), : NAs introduced by coercion\nWarning in dist(rbind(data[id, , drop = FALSE], data[id.neigh, , drop =\nFALSE]), : NAs introduced by coercion\nWarning in dist(rbind(data[id, , drop = FALSE], data[id.neigh, , drop =\nFALSE]), : NAs introduced by coercion\nWarning in dist(rbind(data[id, , drop = FALSE], data[id.neigh, , drop =\nFALSE]), : NAs introduced by coercion\nWarning in dist(rbind(data[id, , drop = FALSE], data[id.neigh, , drop =\nFALSE]), : NAs introduced by coercion\nWarning in dist(rbind(data[id, , drop = FALSE], data[id.neigh, , drop =\nFALSE]), : NAs introduced by coercion\nWarning in dist(rbind(data[id, , drop = FALSE], data[id.neigh, , drop =\nFALSE]), : NAs introduced by coercion\nWarning in dist(rbind(data[id, , drop = FALSE], data[id.neigh, , drop =\nFALSE]), : NAs introduced by coercion\nWarning in dist(rbind(data[id, , drop = FALSE], data[id.neigh, , drop =\nFALSE]), : NAs introduced by coercion\nWarning in dist(rbind(data[id, , drop = FALSE], data[id.neigh, , drop =\nFALSE]), : NAs introduced by coercion\nWarning in dist(rbind(data[id, , drop = FALSE], data[id.neigh, , drop =\nFALSE]), : NAs introduced by coercion\nWarning in dist(rbind(data[id, , drop = FALSE], data[id.neigh, , drop =\nFALSE]), : NAs introduced by coercion\nWarning in dist(rbind(data[id, , drop = FALSE], data[id.neigh, , drop =\nFALSE]), : NAs introduced by coercion\nWarning in dist(rbind(data[id, , drop = FALSE], data[id.neigh, , drop =\nFALSE]), : NAs introduced by coercion\nWarning in dist(rbind(data[id, , drop = FALSE], data[id.neigh, , drop =\nFALSE]), : NAs introduced by coercion\nWarning in dist(rbind(data[id, , drop = FALSE], data[id.neigh, , drop =\nFALSE]), : NAs introduced by coercion\nWarning in dist(rbind(data[id, , drop = FALSE], data[id.neigh, , drop =\nFALSE]), : NAs introduced by coercion\nWarning in dist(rbind(data[id, , drop = FALSE], data[id.neigh, , drop =\nFALSE]), : NAs introduced by coercion\nWarning in dist(rbind(data[id, , drop = FALSE], data[id.neigh, , drop =\nFALSE]), : NAs introduced by coercion\nWarning in dist(rbind(data[id, , drop = FALSE], data[id.neigh, , drop =\nFALSE]), : NAs introduced by coercion\nWarning in dist(rbind(data[id, , drop = FALSE], data[id.neigh, , drop =\nFALSE]), : NAs introduced by coercion\nWarning in dist(rbind(data[id, , drop = FALSE], data[id.neigh, , drop =\nFALSE]), : NAs introduced by coercion\nWarning in dist(rbind(data[id, , drop = FALSE], data[id.neigh, , drop =\nFALSE]), : NAs introduced by coercion\nWarning in dist(rbind(data[id, , drop = FALSE], data[id.neigh, , drop =\nFALSE]), : NAs introduced by coercion\nWarning in dist(rbind(data[id, , drop = FALSE], data[id.neigh, , drop =\nFALSE]), : NAs introduced by coercion\nWarning in dist(rbind(data[id, , drop = FALSE], data[id.neigh, , drop =\nFALSE]), : NAs introduced by coercion\nWarning in dist(rbind(data[id, , drop = FALSE], data[id.neigh, , drop =\nFALSE]), : NAs introduced by coercion\nWarning in dist(rbind(data[id, , drop = FALSE], data[id.neigh, , drop =\nFALSE]), : NAs introduced by coercion\nWarning in dist(rbind(data[id, , drop = FALSE], data[id.neigh, , drop =\nFALSE]), : NAs introduced by coercion\nWarning in dist(rbind(data[id, , drop = FALSE], data[id.neigh, , drop =\nFALSE]), : NAs introduced by coercion\nWarning in dist(rbind(data[id, , drop = FALSE], data[id.neigh, , drop =\nFALSE]), : NAs introduced by coercion\nWarning in dist(rbind(data[id, , drop = FALSE], data[id.neigh, , drop =\nFALSE]), : NAs introduced by coercion\nWarning in dist(rbind(data[id, , drop = FALSE], data[id.neigh, , drop =\nFALSE]), : NAs introduced by coercion\nWarning in dist(rbind(data[id, , drop = FALSE], data[id.neigh, , drop =\nFALSE]), : NAs introduced by coercion\nWarning in dist(rbind(data[id, , drop = FALSE], data[id.neigh, , drop =\nFALSE]), : NAs introduced by coercion\nWarning in dist(rbind(data[id, , drop = FALSE], data[id.neigh, , drop =\nFALSE]), : NAs introduced by coercion\nWarning in dist(rbind(data[id, , drop = FALSE], data[id.neigh, , drop =\nFALSE]), : NAs introduced by coercion\nWarning in dist(rbind(data[id, , drop = FALSE], data[id.neigh, , drop =\nFALSE]), : NAs introduced by coercion\nWarning in dist(rbind(data[id, , drop = FALSE], data[id.neigh, , drop =\nFALSE]), : NAs introduced by coercion\nWarning in dist(rbind(data[id, , drop = FALSE], data[id.neigh, , drop =\nFALSE]), : NAs introduced by coercion\nWarning in dist(rbind(data[id, , drop = FALSE], data[id.neigh, , drop =\nFALSE]), : NAs introduced by coercion\n```\n\n\n:::\n:::\n\n\n\nFor each observation, this gives the pairwise dissimilarity between its values on the five variables and the values for the neighbouring observation (from the neighbour list). Basically, this is the notion of a generalised weight for a spatial weights matrix.\n\nNext, We will incorporate these costs into a weights object in the same way as we did in the calculation of inverse of distance weights. In other words, we convert the neighbour list to a list weights object by specifying the just computed ***lcosts*** as the weights.\n\nIn order to achieve this, [*nb2listw()*](https://r-spatial.github.io/spdep/reference/nb2listw.html) of **spdep** package is used as shown in the code chunk below.\n\nNote that we specify the *style* as **B** to make sure the cost values are not row-standardised.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshan.w <- nb2listw(shan.nb, \n                   lcosts, \n                   style=\"B\")\nsummary(shan.w)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 55 \nNumber of nonzero links: 264 \nPercentage nonzero weights: 8.727273 \nAverage number of links: 4.8 \nLink number distribution:\n\n 2  3  4  5  6  7  8  9 \n 5  9  7 21  4  3  5  1 \n5 least connected regions:\n3 5 7 9 47 with 2 links\n1 most connected region:\n8 with 9 links\n\nWeights style: B \nWeights constants summary:\n   n   nn      S0           S1           S2\nB 55 3025 5776751 525204394585 3.740688e+12\n```\n\n\n:::\n:::\n\n\n\nNow, we can compute our minimum spanning tree. We will use the *mstree()* function of the **spdep** package to achieve this.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshan.mst <- mstree(shan.w)\n```\n:::\n\n\n\nWe can check the dimensions of the spanning tree by using the dim() function.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndim(shan.mst)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 54  3\n```\n\n\n:::\n:::\n\n\n\nHere, we see that the dimension is 54 instead of 55, and that is due to the fact that the mst takes note of the number of links/edges between the nodes and not the nodes themselves. We cna now plot the mst.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(st_geometry(shan_sf), \n                 border=gray(.5))\nplot.mst(shan.mst, \n         coords, \n         col=\"blue\", \n         cex.lab=0.7, \n         cex.circles=0.005, \n         add=TRUE)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex08_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\n\nThe plot method of MST also shows the number fo observations for each node. We also see that compared to the neighbours plot before, in this plot, there is only one line passung through and connecting all of the nodes.\n\n#### 8.1.3 Computing Spatially constrained clusters using SKATER approach\n\nWe will now use the skater() function to compute the spatially constrained clusters. The *skater()* takes three mandatory arguments: - the first two columns of the MST matrix (i.e. not the cost), - the data matrix (to update the costs as units are being grouped), and - the number of cuts. Note: It is set to **one less than the number of clusters**. So, the value specified is **not** the number of clusters, but the number of cuts in the graph, one less than the number of clusters.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclust6 <- skater(edges = shan.mst[,1:2], \n                 data = ict[6:11], \n                 method = \"euclidean\", \n                 ncuts = 5)\n\nstr(clust6)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 8\n $ groups      : num [1:55] 2 4 4 4 5 4 1 4 4 4 ...\n $ edges.groups:List of 6\n  ..$ :List of 3\n  .. ..$ node: num [1:40] 34 27 33 41 36 40 16 15 24 13 ...\n  .. ..$ edge: num [1:39, 1:3] 27 33 34 41 36 40 15 16 13 13 ...\n  .. ..$ ssw : num 170696\n  ..$ :List of 3\n  .. ..$ node: num 1\n  .. ..$ edge: num[0 , 1:3] \n  .. ..$ ssw : num 0\n  ..$ :List of 3\n  .. ..$ node: num [1:2] 53 22\n  .. ..$ edge: num [1, 1:3] 53 22 22547\n  .. ..$ ssw : num 22547\n  ..$ :List of 3\n  .. ..$ node: num [1:10] 6 8 25 9 2 46 31 4 10 3\n  .. ..$ edge: num [1:9, 1:3] 8 8 8 9 8 25 6 6 8 2 ...\n  .. ..$ ssw : num 59968\n  ..$ :List of 3\n  .. ..$ node: num 5\n  .. ..$ edge: num[0 , 1:3] \n  .. ..$ ssw : num 0\n  ..$ :List of 3\n  .. ..$ node: num 26\n  .. ..$ edge: num[0 , 1:3] \n  .. ..$ ssw : num 0\n $ not.prune   : NULL\n $ candidates  : int [1:6] 1 2 3 4 5 6\n $ ssto        : num 552126\n $ ssw         : num [1:6] 552126 453999 386398 308273 275862 ...\n $ crit        : num [1:2] 1 Inf\n $ vec.crit    : num [1:55] 1 1 1 1 1 1 1 1 1 1 ...\n - attr(*, \"class\")= chr \"skater\"\n```\n\n\n:::\n:::\n\n\n\nWe can also check the cluster assignments and the number of observations in each cluster using the codelines below.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nccs6 <- clust6$groups\nccs6\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 2 4 4 4 5 4 1 4 4 4 1 1 1 1 1 1 1 1 1 1 1 3 1 1 4 6 1 1 1 1 4 1 1 1 1 1 1 1\n[39] 1 1 1 1 1 1 1 4 1 1 1 1 1 1 3 1 1\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntable(ccs6)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nccs6\n 1  2  3  4  5  6 \n40  1  2 10  1  1 \n```\n\n\n:::\n:::\n\n\n\nLastly, we can also plot the pruned tree that shows the five clusters on top of the townshop area.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(st_geometry(shan_sf), \n     border=gray(.5))\nplot(clust6, \n     coords, \n     cex.lab=.7,\n     groups.colors=c(\"navy\",\"purple\",\"red\", \"brown\", \"pink\"),\n     cex.circles=0.005, \n     add=TRUE)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in segments(coords[id1, 1], coords[id1, 2], coords[id2, 1], coords[id2,\n: \"add\" is not a graphical parameter\nWarning in segments(coords[id1, 1], coords[id1, 2], coords[id2, 1], coords[id2,\n: \"add\" is not a graphical parameter\nWarning in segments(coords[id1, 1], coords[id1, 2], coords[id2, 1], coords[id2,\n: \"add\" is not a graphical parameter\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](Hands-on_Ex08_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n\n\n\n#### 8.1.4 Visualising the clusters in choropleth maps\n\nWe will now plot the newly derived clusters using the SKATER approach.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshan_sf_cluster <- cbind(shan_sf, as.matrix(ccs6)) %>% \n  rename(`CLUSTER`=`as.matrix.ccs6.`)\n\ngroups_mat <- as.matrix(clust6$groups)\nshan_sf_spatialcluster <- cbind(shan_sf_cluster, as.factor(groups_mat)) %>%\n  rename(`SP_CLUSTER`=`as.factor.groups_mat.`)\nqtm(shan_sf_spatialcluster, \"SP_CLUSTER\")\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex08_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n:::\n\n\n\nFor easy comparison, it will be better to place both the hierarchical clustering and spatially constrained hierarchical clustering maps next to each other.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhclust.map <- qtm(shan_sf_cluster,\n                  \"CLUSTER\") + \n  tm_borders(alpha = 0.5) \n\nshclust.map <- qtm(shan_sf_spatialcluster,\n                   \"SP_CLUSTER\") + \n  tm_borders(alpha = 0.5) \n\ntmap_arrange(hclust.map, shclust.map,\n             asp=NA, ncol=2)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: One tm layer group has duplicated layer types, which are omitted. To\ndraw multiple layers of the same type, use multiple layer groups (i.e. specify\ntm_shape prior to each of them).\nWarning: One tm layer group has duplicated layer types, which are omitted. To\ndraw multiple layers of the same type, use multiple layer groups (i.e. specify\ntm_shape prior to each of them).\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](Hands-on_Ex08_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n:::\n\n\n\n## 8.2 Spatially Constrained Clustering: Using ClustGeo Method\n\n[**ClustGeo**](https://cran.r-project.org/web/packages/ClustGeo/) package is an R package specially designed to support the need of performing spatially constrained cluster analysis. More specifically, it provides a Ward-like hierarchical clustering algorithm called `hclustgeo()` including spatial/geographical constraints.\n\nIn the nutshell, the algorithm uses two dissimilarity matrices D0 and D1 along with a mixing parameter alpha, whereby the value of alpha must be a real number between \\[0, 1\\]. D0 can be non-Euclidean and the weights of the observations can be non-uniform. It gives the dissimilarities in the **attribute/clustering variable space**. D1, on the other hand, gives the dissimilarities in the **constraint space**. The criterion minimised at each stage is a convex combination of the homogeneity criterion calculated with D0 and the homogeneity criterion calculated with D1.\n\nThe idea is then to determine a value of alpha which increases the spatial contiguity without deteriorating too much the quality of the solution based on the variables of interest. This need is supported by a function called `choicealpha()`.\n\n#### 8.2.1 Ward-like Hierarchical Clustering \n\nClustGeo package provides function called `hclustgeo()` to perform a typical Ward-like hierarchical clustering just like `hclust()` you learned in previous section.\n\nTo perform non-spatially constrained hierarchical clustering, we only need to provide the function a dissimilarity matrix as shown in the code chunk below.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nproxmat <- dist(ict, method='euclidean')\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in dist(ict, method = \"euclidean\"): NAs introduced by coercion\n```\n\n\n:::\n\n```{.r .cell-code}\nnongeo_cluster <- hclustgeo(proxmat)\nplot(nongeo_cluster, cex = 0.5)\nrect.hclust(nongeo_cluster, \n            k = 6, \n            border = 2:5)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex08_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n\n\n\n#### 8.2.2 Mapping the Clusters formed\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngroups <- as.factor(cutree(nongeo_cluster, k=6))\n\nshan_sf_ngeo_cluster <- cbind(shan_sf, as.matrix(groups)) %>%\n  rename(`CLUSTER` = `as.matrix.groups.`)\n\nqtm(shan_sf_ngeo_cluster, \"CLUSTER\")\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex08_files/figure-html/unnamed-chunk-18-1.png){width=672}\n:::\n:::\n\n\n\n#### 8.2.3 Spatially Constrained Hierarchical Clustering \n\nBefore we can proceed to derive the spatially constrained hierarchical clustering, a spatial distance matrix will be computed using the *st_distance()* of the **sf** package.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndist <- st_distance(shan_sf, shan_sf)\ndistmat <- as.dist(dist)\n```\n:::\n\n\n\nNext, `choicealpha()` will be used to determine a suitable value for the mixing parameter alpha as shown in the code chunk below.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncr <- choicealpha(proxmat, distmat, range.alpha = seq(0, 1, 0.1), K=6, graph = TRUE)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex08_files/figure-html/unnamed-chunk-20-1.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](Hands-on_Ex08_files/figure-html/unnamed-chunk-20-2.png){width=672}\n:::\n:::\n\n\n\nBased on the plots, an alpha value of 0.3 will be used.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclustG <- hclustgeo(proxmat, distmat, alpha = 0.2)\n```\n:::\n\n\n\nNext, I will use cutree() to derive the cluster object.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngroups <- as.factor(cutree(clustG, k=6))\n```\n:::\n\n\n\nWe will then join back the group list with *shan_sf* polygon feature data frame by using the code chunk below.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshan_sf_Gcluster <- cbind(shan_sf, as.matrix(groups)) %>%\n  rename(`CLUSTER` = `as.matrix.groups.`)\n```\n:::\n\n\n\nFinally, we can plot the newly formed clusters.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nqtm(shan_sf_Gcluster, \"CLUSTER\")\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex08_files/figure-html/unnamed-chunk-24-1.png){width=672}\n:::\n:::\n\n\n\n## \n",
    "supporting": [
      "Hands-on_Ex08_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}