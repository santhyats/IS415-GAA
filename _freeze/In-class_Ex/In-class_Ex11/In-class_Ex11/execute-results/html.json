{
  "hash": "83df705570068f35cab8e4cfd6c58416",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"In-class Exercise 11\"\nauthor: \"Santhya Selvan\"\ndate: \"4 November 2024\"\ndate-modified: \"last-modified\"\nexecute: \n  eval: true\n  echo: true\n  freeze: true\n---\n\n\n\n## 11.0 Getting Started\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(tidyverse, sf, tmap, httr, performance)\n```\n:::\n\n\n\n## 11.1 Data Wrangling\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfolder_path <- \"data/aspatial\"\nfile_list <- list.files(path = folder_path,\n                        pattern = \"^realis.*\\\\.csv$\",\n                        full.names = TRUE)\n\nrealis_data <- file_list %>% \n  map_dfr(read_csv)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: One or more parsing issues, call `problems()` on your data frame for details,\ne.g.:\n  dat <- vroom(...)\n  problems(dat)\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 10000 Columns: 21\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (15): Project Name, Sale Date, Address, Type of Sale, Type of Area, Nett...\ndbl  (2): Area (SQM), Number of Units\nnum  (4): Transacted Price ($), Area (SQFT), Unit Price ($ PSF), Unit Price ...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\nRows: 6643 Columns: 21\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (15): Project Name, Sale Date, Address, Type of Sale, Type of Area, Nett...\ndbl  (1): Number of Units\nnum  (5): Transacted Price ($), Area (SQFT), Unit Price ($ PSF), Area (SQM),...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncondo_resale <- realis_data %>% \n  mutate(`Sale Date` = dmy(`Sale Date`)) %>% \n  filter(`Type of Sale` == \"Resale\" &\n           `Property Type` == \"Condominium\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nurl <- \"https://onemap.gov.sg/api/common/elastic/search\"\nfound <- data.frame()\nnot_found <- data.frame()\npostcode <- unique(condo_resale$'Postal Code')\n\nfor(postcode in postcode){\n  query <- list('searchVal' = postcode,\n                'returnGeom' = 'Y',\n                'getAddrDetails' = 'Y', \n                'pageNum' = '1')\n  \n  res <- GET(url, query = query)\n  if((content(res)$found)!= 0){\n    found<- rbind(found, data.frame(content(res))[4:13])\n  } else{not_found <- data.frame(postcode)}\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nfound <- found %>% \n  select(c(6:8)) %>% \n  rename(POSTAL = `results.POSTAL`,\n         XCOORD = `results.X`,\n         YCOORD = `results.Y`)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncondo_resale_geocoded <- left_join(\n  \n  condo_resale, found, by = c('Postal Code' = 'POSTAL')\n)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#always need to start from the X-coord first and then the y-coord\n\ncondo_resale_sf <- st_as_sf(condo_resale_geocoded, \n                             coords = c(\"XCOORD\", \"YCOORD\"),\n                             crs = 3414)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\noverlapping_points <- condo_resale_sf %>% \n  mutate(overlap = lengths(st_equals(., .)) > 1)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncondo_resale_sf <- condo_resale_sf %>% \n  st_jitter(amount = 2)\n```\n:::\n\n\n\n## Take - Home 2:\n\n-   Convert the multipolygons to single polygons\n\n-   Choose the polygon with the largest area to represent the province\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsf_polygon <- province_sf %>% \n  st_cast(\"POLYGON\") %>% \n  mutate(area = st_area(.))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nprovinced_cleaned <- sf_polygon %>% \n    group_by(ADM1_EN) %>% \n    filter(area == max(area)) %>% \n    ungroup() %>% \n    select(-area) %>% \n    select(ADM1_EN)\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}