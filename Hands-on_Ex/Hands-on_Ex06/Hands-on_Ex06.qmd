---
title: "6 Global and Local measures of Spatial Association"
author: "Santhya Selvan"
date: "September 19, 2024"
date-modified: "last-modified"
execute: 
  eval: true
  echo: true
  freeze: true
---

## 6.1 Overview

In this Hands-on, I will be exploring how to compute Global Measures of Spatial Autocorrelation (GMSA) using the **spdep** package.

In spatial policy, one of the main development objective of the local government and planners is to ensure equal distribution of development in the province. Our task in this study, hence, is to apply appropriate spatial statistical methods to discover if development are even distributed geographically. If the answer is **No**. Then, our next question will be “is there sign of spatial clustering?”. And, if the answer for this question is yes, then our next question will be “where are these clusters?”

In this case study, we are interested to examine the spatial pattern of a selected development indicator (i.e. GDP per capita) of [Hunan Provice](https://en.wikipedia.org/wiki/Hunan), People Republic of China.

First and foremost, I will download the necessary packages, mainly sf, tidyverse, spdep and tmap.

```{r}
pacman:: p_load(sf, spdep, tidyverse, tmap )
```

## 6.2 Study Area and Data

For this exercise, I will use 2 data sets:

-   Hunan province administrative boundary layer at county level. This is a geospatial data set in ESRI shapefile format.

-   Hunan_2012.csv: This csv file contains selected Hunan’s local development indicators in 2012.

#### 6.2.1 Importing the data

First, I will use the *st_read()* function of the sf package to import the shapefiles into our R environment.

```{r}
hunan3 <- st_read(dsn="data/geospatial",
                  layer="Hunan")
```

I will also read the csv file into our environment using the *read_csv()* function.

```{r}
hunan2012_3<- read_csv("data/aspatial/Hunan_2012.csv")
```

Lastly, I will perform a relational join to join the attributes from the *hunan2012_3* dataframe to the *hunan3* dataframe. This is done by using the *left_join()* function of the **dplyr** package.

```{r}
hunan3 <- left_join(hunan3,hunan2012_3) %>% 
 select(1:4, 7, 15)
```

#### 6.2.2 Visualising Regional Development Indicators

In this section, we will plot a chloropeth map that will show us the distribution of GDPPC 2012. This will be done using the qtm() function of the **tmap** package.

```{r}
equal <- tm_shape(hunan3) +
  tm_fill("GDPPC",
          n = 5,
          style = "equal") +
  tm_borders(alpha = 0.5) +
  tm_layout(main.title = "Equal interval classification")

quantile <- tm_shape(hunan3) +
  tm_fill("GDPPC",
          n = 5,
          style = "quantile") +
  tm_borders(alpha = 0.5) +
  tm_layout(main.title = "Equal quantile classification")

tmap_arrange(equal, 
             quantile, 
             asp=1, 
             ncol=2)
```

## 6.3 Global Measures of Spatial Autocorrelation

#### 6.3.1 Computing Contiguity Spatial Weights

Before we can compute the global spatial autocorrelation, we would first need to derive the spatial weights of the study area. Spatial weights are the neighbourhood relationships between the spatial units.

We will derive the contiguity neighbours list using the *poly2nb()* function of the **spdep** package. By default, this function returns a matrice of neighbours of the spatial untis, derived by the Queen's method.

```{r}
wm_q3 <- poly2nb(hunan3, 
                queen=TRUE)
summary(wm_q3)
```

From the summary above, we see that there are a total of 88 spatial regions in hunan and the most connected region has 11 links. There are also 2 least connected regions with only one neighbour each.

#### 6.3.2 Row-standardized Weights Matrix

Next, we need to assign weights to each neighboring polygon. In our case, each neighboring polygon will be assigned equal weight (style=“W”). This is accomplished by assigning the fraction 1/(#ofneighbors) to each neighboring county then summing the weighted income values. While this is the most intuitive way to summaries the neighbors’ values it has one drawback in that polygons along the edges of the study area will base their lagged values on fewer polygons thus potentially over- or under-estimating the true nature of the spatial autocorrelation in the data. For this example, we’ll stick with the style=“W” option for simplicity’s sake but note that other more robust options are available, notably style=“B”.

```{r}
rswm_q3 <- nb2listw(wm_q3, 
                   style="W", 
                   zero.policy = TRUE)
rswm_q3
```

## 6.4 Global Measures of Spatial Autocorrelation- Moran's Test

#### 6.4.1 Moran's I Test

In this section, we will be performing the Maron's I statistics test using the *moran.test()* function of the **spdep** package.

```{r}
moran.test(hunan3$GDPPC, 
           listw=rswm_q3, 
           zero.policy = TRUE, 
           na.action=na.omit)
```

From the statistics derived above, we see that the p-value is extremely small and that the alternate hypothesis is greater, enabling us to reject the null hypothesis (which states that there is no correlation between the weighted spatial units) and conclude that there is significant spatial autocorrelation between the weighted spatial units. This is further corroborated by the positive value of the Moran I Statistic.

In context, this means that counties with similar GDPPC Values are more close to one another spatially as compared to counties that have varying levels.

#### 6.4.2 Computing Monte Carlo Moran's I Statistic

We will now perform the Monte Carlo Simulation for the Moran's I Statistic using the *moran.mc()* function, also from the **spdep** package.

```{r}
set.seed(1234)
bperm= moran.mc(hunan3$GDPPC, 
                listw=rswm_q3, 
                nsim=999, 
                zero.policy = TRUE, 
                na.action=na.omit)
bperm
```

From the statistics above, we once again see that the p-value is lower than 0.05, and we can reject the null hypothesis and accept the claim that the weighted spatial units are positively autocorrelated.

#### 6.4.3 Visualis ing Monte Carlo Moran's I

It is always a good practice for us the examine the simulated Moran’s I test statistics in greater detail. This can be achieved by plotting the distribution of the statistical values as a histogram by using the code chunk below.

In the code chunk below [`hist()`](https://www.rdocumentation.org/packages/graphics/versions/3.6.2/topics/hist) and [`abline()`](https://www.rdocumentation.org/packages/graphics/versions/3.6.2/topics/abline) of R Graphics are used.

```{r}
hist(bperm$res, 
     freq=TRUE, 
     breaks=20, 
     xlab="Simulated Moran's I",)
abline(v=0, 
       col="purple") 
```
